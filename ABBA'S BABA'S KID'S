  db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. DocumentcitiesSF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle andor its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Google Cloud newsletter Subscribe Language Copied to clipboard Copied to clipboard
(default)
Filevar citiesRef = db.collection("cities"); citiesRef.doc("SF").set({ name: "San Francisco", state: "CA", country: "USA", capital: false, population: 860000, regions: ["west_coast", "norcal"] }); citiesRef.doc("LA").set({ name: "Los Angeles", state: "CA", country: "USA", capital: false, population: 3900000, regions: ["west_coast", "socal"] }); citiesRef.doc("DC").set({ name: "Washington, D.C.", state: null, country: "USA", capital: true, population: 680000, regions: ["east_coast"] }); citiesRef.doc("TOK").set({ name: "Tokyo", state: null, country: "Japan", capital: true, population: 9000000, regions: ["kanto", "honshu"] }); citiesRef.doc("BJ").set({ name: "Beijing", state: null, country: "China", capital: true, population: 21500000, regions: ["jingjinji", "hebei"] }); Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index: Collection Field indexed Query scope cities arrow_upward name Collection cities arrow_upward state Collection cities arrow_upward country Collection cities arrow_upward capital Collection cities arrow_upward population Collection cities arrow_downward name Collection cities arrow_downward state Collection cities arrow_downward country Collection cities arrow_downward capital Collection cities arrow_downward population Collection cities array-contains regions Collection Queries supported by single-field indexes Using these automatically created single-field indexes, you can run simple queries like the following: Web const stateQuery = citiesRef.where("state", "==", "CA"); const populationQuery = citiesRef.where("population", "<", 100000); const nameQuery = citiesRef.where("name", ">=", "San Francisco"); You can also create in and compound equality (==) queries: Web citiesRef.where('country', 'in', ["USA", "Japan", "China"])Error loading documentsCompound equality queries citiesRef.where("state", "==", "CO").where("name", "==", "Denver") citiesRef.where("country", "==", "USA") .where("capital", "==", false) .where("state", "==", "CA") .where("population", "==", 860000) If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query. The array-contains index allows you to query the regions array field: Web citiesRef.where("regions", "array-contains", "west_coast")Error loading documentarray-any and array-contains use the same indexes citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) Queries supported by composite indexes Firestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries: Web citiesRef.where("country", "==", "USA").orderBy("population", "asc") citiesRef.where("country", "==", "USA").where("population", "<", 3800000) citiesRef.where("country", "==", "USA").where("population", ">", 690000)Error loading documentsin and == clauses use the same index citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause. Collection Fields indexed Query scope cities arrow_upward (or arrow_downward) country, arrow_upward population Collection To run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population: Web citiesRef.where("country", "==", "USA").orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", "<", 3800000) .orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", ">", 690000) .orderBy("population", "desc") citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) .orderBy("population", "desc") Collection Fields indexed Query scope cities arrow_upward country, arrow_upward population Collection cities arrow_upward country, arrow_downward population Collection You also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses. Web citiesRef.where("regions", "array-contains", "east_coast") .where("capital", "==", true)Error loading documentarray-contains-any and array-contains use the same index citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) .where("capital", "==", true) Collection Fields indexed Query scope cities array-contains tags, arrow_upward (or arrow_downward) capital Collection Queries supported by collection group indexes To demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents: Web var citiesRef = db.collection("cities"); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Bridge", category : "bridge" }); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Park", category : "park" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Gallery of Art", category : "museum" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Mall", category : "park" }); Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection Web citiesRef.doc("SF").collection("landmarks").where("category", "==", "park") citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"]) Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection group With this index enabled, you can query the landmarks collection group: Web var landmarksGroupRef = db.collectionGroup("landmarks"); landmarksGroupRef.where("category", "==", "park") landmarksGroupRef.where("category", "in", ["park", "museum"]) To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions. For example, you can run the following collection group query without enabling an additional index: Web db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. DocumentError loading documentscitiesError loading documentSF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle andError loading documentsor its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Google Cloud newsletter Subscribe Language Copied to clipboard Copied to clipboardError loading documentDatabase location: nam5Start a collection1 Give the collection an ID2 Parent path/var citiesRef = db.collection("cities"); citiesRef.doc("SF").set({ name: "San Francisco", state: "CA", country: "USA", capital: false, population: 860000, regions: ["west_coast", "norcal"] }); citiesRef.doc("LA").set({ name: "Los Angeles", state: "CA", country: "USA", capital: false, population: 3900000, regions: ["west_coast", "socal"] }); citiesRef.doc("DC").set({ name: "Washington, D.C.", state: null, country: "USA", capital: true, population: 680000, regions: ["east_coast"] }); citiesRef.doc("TOK").set({ name: "Tokyo", state: null, country: "Japan", capital: true, population: 9000000, regions: ["kanto", "honshu"] }); citiesRef.doc("BJ").set({ name: "Beijing", state: null, country: "China", capital: true, population: 21500000, regions: ["jingjinji", "hebei"] }); Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index: Collection Field indexed Query scope cities arrow_upward name Collection cities arrow_upward state Collection cities arrow_upward country Collection cities arrow_upward capital Collection cities arrow_upward population Collection cities arrow_downward name Collection cities arrow_downward state Collection cities arrow_downward country Collection cities arrow_downward capital Collection cities arrow_downward population Collection cities array-contains regions Collection Queries supported by single-field indexes Using these automatically created single-field indexes, you can run simple queries like the following: Web const stateQuery = citiesRef.where("state", "==", "CA"); const populationQuery = citiesRef.where("population", "<", 100000); const nameQuery = citiesRef.where("name", ">=", "San Francisco"); You can also create in and compound equality (==) queries: Web citiesRef.where('country', 'in', ["USA", "Japan", "China"]) / Compound equality queries citiesRef.where("state", "==", "CO").where("name", "==", "Denver") citiesRef.where("country", "==", "USA") .where("capital", "==", false) .where("state", "==", "CA") .where("population", "==", 860000) If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query. The array-contains index allows you to query the regions array field: Web citiesRef.where("regions", "array-contains", "west_coast") / array-contains-any and array-contains use the same indexes citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) Queries supported by composite indexes Firestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries: Web citiesRef.where("country", "==", "USA").orderBy("population", "asc") citiesRef.where("country", "==", "USA").where("population", "<", 3800000) citiesRef.where("country", "==", "USA").where("population", ">", 690000) / in and == clauses use the same index citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause. Collection Fields indexed Query scope cities arrow_upward (or arrow_downward) country, arrow_upward population Collection To run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population: Web citiesRef.where("country", "==", "USA").orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", "<", 3800000) .orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", ">", 690000) .orderBy("population", "desc") citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) .orderBy("population", "desc") Collection Fields indexed Query scope cities arrow_upward country, arrow_upward population Collection cities arrow_upward country, arrow_downward population Collection You also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses. Web citiesRef.where("regions", "array-contains", "east_coast") .where("capital", "==", true) / array-contains-any and array-contains use the same index citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) .where("capital", "==", true) Collection Fields indexed Query scope cities array-contains tags, arrow_upward (or arrow_downward) capital Collection Queries supported by collection group indexes To demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents: Web var citiesRef = db.collection("cities"); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Bridge", category : "bridge" }); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Park", category : "park" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Gallery of Art", category : "museum" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Mall", category : "park" }); Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection Web citiesRef.doc("SF").collection("landmarks").where("category", "==", "park") citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"]) Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection group With this index enabled, you can query the landmarks collection group: Web var landmarksGroupRef = db.collectionGroup("landmarks"); landmarksGroupRef.where("category", "==", "park") landmarksGroupRef.where("category", "in", ["park", "museum"]) To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions. For example, you can run the following collection group query without enabling an additional index: Web db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. Document /cities/SF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Googletemperatures.wintertemperatures.summervar citiesRef = db.collection("cities");
citiesRef.doc("SF").set({    name: "San Francisco", state: "CA", country: "USA",    capital: false, population: 860000,    regions: ["west_coast", "norcal"] });citiesRef.doc("LA").set({    name: "Los Angeles", state: "CA", country: "USA",    capital: false, population: 3900000,    regions: ["west_coast", "socal"] });citiesRef.doc("DC").set({    name: "Washington, D.C.", state: null, country: "USA",    capital: true, population: 680000,    regions: ["east_coast"] });citiesRef.doc("TOK").set({    name: "Tokyo", state: null, country: "Japan",    capital: true, population: 9000000,    regions: ["kanto", "honshu"] });citiesRef.doc("BJ").set({    name: "Beijing", state: null, country: "China",    capital: true, population: 21500000,    regions: ["jingjinji", "hebei"] });Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index:
Collection	Field indexed	Query scopecities	arrow_upward name	Collectioncities	arrow_upward state	Collectioncities	arrow_upward country	Collectioncities	arrow_upward capital	Collectioncities	arrow_upward population	Collectioncities	arrow_downward name	Collectioncities	arrow_downward state	Collectioncities	arrow_downward country	Collectioncities	arrow_downward capital	Collectioncities	arrow_downward population	Collectioncities	array-contains regions	CollectionQueries supported by single-field indexesUsing these automatically created single-field indexes, you can run simple queries like the following:
Webconst stateQuery = citiesRef.where("state", "==", "CA");const populationQuery = citiesRef.where("population", "<", 100000);const nameQuery = citiesRef.where("name", ">=", "San Francisco");You can also create in and compound equality (==) queries:
WebcitiesRef.where('country', 'in', ["USA", "Japan", "China"])
// Compound equality queriescitiesRef.where("state", "==", "CO").where("name", "==", "Denver")citiesRef.where("country", "==", "USA")         .where("capital", "==", false)         .where("state", "==", "CA")         .where("population", "==", 860000)If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query.
The array-contains index allows you to query the regions array field:
WebcitiesRef.where("regions", "array-contains", "west_coast")// array-contains-any and array-contains use the same indexescitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])Queries supported by composite indexesFirestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "asc")citiesRef.where("country", "==", "USA").where("population", "<", 3800000)citiesRef.where("country", "==", "USA").where("population", ">", 690000)// in and == clauses use the same indexcitiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause.
Collection	Fields indexed	Query scopecities	arrow_upward (or arrow_downward) country, arrow_upward population	CollectionTo run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", "<", 3800000)         .orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", ">", 690000)         .orderBy("population", "desc")
citiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)         .orderBy("population", "desc")Collection	Fields indexed	Query scopecities	arrow_upward country, arrow_upward population	Collectioncities	arrow_upward country, arrow_downward population	CollectionYou also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses.
WebcitiesRef.where("regions", "array-contains", "east_coast")         .where("capital", "==", true)
// array-contains-any and array-contains use the same indexcitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])         .where("capital", "==", true)Collection	Fields indexed	Query scopecities	array-contains tags, arrow_upward (or arrow_downward) capital	CollectionQueries supported by collection group indexesTo demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents:
Webvar citiesRef = db.collection("cities");
citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Bridge",    category : "bridge" });citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Park",    category : "park" });
citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Gallery of Art",    category : "museum" });citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Mall",    category : "park" });Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	CollectionWebcitiesRef.doc("SF").collection("landmarks").where("category", "==", "park")citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"])Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	Collection groupWith this index enabled, you can query the landmarks collection group:
Webvar landmarksGroupRef = db.collectionGroup("landmarks");
landmarksGroupRef.where("category", "==", "park")landmarksGroupRef.where("category", "in", ["park", "museum"])To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions.
For example, you can run the following collection group query without enabling an additional index:
Webdb.collectionGroup("landmarks").get()Index entriesYour project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit.
The following example demonstrates the index entries of a document.
Document/cities/SF
city_name : "San Francisco"temperatures : {summer: 67, winter: 55}neighborhoods : ["Mission", "Downtown", "Marina"]
Single-Field indexescity_name ASCcity_name DESCtemperatures.summer ASCtemperatures.summer DESCtemperatures.winter ASCtemperatures.winter DESCneighborhoods Array Contains (ASC and DESC)Composite indexescity_name ASC, neighborhoods ARRAYcity_name DESC, neighborhoods ARRAYIndex entriesThis indexing configuration results in the following 18 index entries for the document:
Index	Indexed dataSingle-field index entries	city_name ASC	city_name: "San Francisco"city_name DESC	city_name: "San Francisco"temperatures.summer ASC	temperatures.summer: 67temperatures.summer DESC	temperatures.summer: 67temperatures.winter ASC	temperatures.winter: 55temperatures.winter DESC	temperatures.winter: 55neighborhoods Array Contains ASC	neighborhoods: "Mission"neighborhoods Array Contains DESC	neighborhoods: "Mission"neighborhoods Array Contains ASC	neighborhoods: "Downtown"neighborhoods Array Contains DESC	neighborhoods: "Downtown"neighborhoods Array Contains ASC	neighborhoods: "Marina"neighborhoods Array Contains DESC	neighborhoods: "Marina"Composite index entries	city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"Indexes and pricingIndexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size.
Taking advantage of index mergingAlthough Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries.
You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app:
collections_bookmark restaurants
class burgerthyme
name : "Burger Thyme"category : "burgers"city : "San Francisco"editors_pick : truestar_rating : 4
Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating:
Webdb.collection("restaurants").where("category", "==", "burgers")                            .orderBy("star_rating")
db.collection("restaurants").where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==" "San Francisco")                            .where("editors_pick", "==", true )                            .orderBy("star_rating")You could create an index for each query:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating	CollectionAs a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward editors_pick, arrow_upward star_rating	CollectionNot only is this set of indexes smaller, it also supports an additional query:
Webdb.collection("restaurants").where("editors_pick", "==", true)                            .orderBy("star_rating")
Indexing limitsThe following limits apply to indexes. For all quotas and limits, see Quotas and Limits.
This page identifies the request quotas and limits for Firestore.
Limit	DetailsMaximum number of composite indexes for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.
You can contact support to request an increase to this limit.
Maximum number of single-field configurations for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit.
Maximum number of index entries for each document
40,000
The number of index entries is the sum of the following for a document:
The number of single-field index entriesThe number of composite index entriesTo see how Firestore turns a document and a set of indexes into index entries, see this index entry count example.
Maximum number of fields in a composite index	100Maximum size of an index entry	7.5 KiB
To see how Firestore calculates index entry size, see index entry size.
Maximum sum of the sizes of a document's index entries	8 MiB
The total size is the sum of the following for a document:
The sum of the size of a document's single-field index entriesThe sum of the size of a document's composite index entriesMaximum size of an indexed field value	1500 bytes
Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results.
Indexing best practicesFor most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases:
Case	DescriptionLarge string fields	If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing.
High write rates to a collection containing documents with sequential values	If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit.
In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit.
TTL fields	If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields.
Large array or map fields	Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing.
For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page.
Was this helpful?
Send feedbackExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2023-10-26 UTC.
Why GoogleChoosing Google CloudTrust and securityOpen cloudMulticloudGlobal infrastructureCustomers and case studiesAnalyst reportsWhitepapersBlogProducts and pricingGoogle Cloud pricingGoogle Workspace pricingSee all productsSolutionsInfrastructure modernizationDatabasesApplication modernizationSmart analyticsArtificial IntelligenceSecurityProductivity & work transformationIndustry solutionsDevOps solutionsSmall business solutionsSee all solutionsResourcesGoogle Cloud documentationGoogle Cloud quickstartsGoogle Cloud MarketplaceLearn about cloud computingSupportCode samplesCloud Architecture CenterTrainingCertificationsGoogle for DevelopersGoogle Cloud for StartupsSystem statusRelease NotesEngageContact salesFind a PartnerBecome a PartnerEventsPodcastsDeveloper CenterPress CornerGoogle Cloud on YouTubeGoogle Cloud Tech on YouTubeFollow on TwitterJoin User ResearchWe're hiring. Join Google Cloud!Google Cloud CommunityAbout GooglePrivacySite termsGoogle Cloud termsOur third decade of climate action: join usSign up for the Google Cloud newsletterSubscribe
LanguageCopied to clipboardCopied to clipboardvar citiesRef = db.collection("cities");
citiesRef.doc("SF").set({    name: "San Francisco", state: "CA", country: "USA",    capital: false, population: 860000,    regions: ["west_coast", "norcal"] });citiesRef.doc("LA").set({    name: "Los Angeles", state: "CA", country: "USA",    capital: false, population: 3900000,    regions: ["west_coast", "socal"] });citiesRef.doc("DC").set({    name: "Washington, D.C.", state: null, country: "USA",    capital: true, population: 680000,    regions: ["east_coast"] });citiesRef.doc("TOK").set({    name: "Tokyo", state: null, country: "Japan",    capital: true, population: 9000000,    regions: ["kanto", "honshu"] });citiesRef.doc("BJ").set({    name: "Beijing", state: null, country: "China",    capital: true, population: 21500000,    regions: ["jingjinji", "hebei"] });Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index:
Collection	Field indexed	Query scopecities	arrow_upward name	Collectioncities	arrow_upward state	Collectioncities	arrow_upward country	Collectioncities	arrow_upward capital	Collectioncities	arrow_upward population	Collectioncities	arrow_downward name	Collectioncities	arrow_downward state	Collectioncities	arrow_downward country	Collectioncities	arrow_downward capital	Collectioncities	arrow_downward population	Collectioncities	array-contains regions	CollectionQueries supported by single-field indexesUsing these automatically created single-field indexes, you can run simple queries like the following:
Webconst stateQuery = citiesRef.where("state", "==", "CA");const populationQuery = citiesRef.where("population", "<", 100000);const nameQuery = citiesRef.where("name", ">=", "San Francisco");You can also create in and compound equality (==) queries:
WebcitiesRef.where('country', 'in', ["USA", "Japan", "China"])
// Compound equality queriescitiesRef.where("state", "==", "CO").where("name", "==", "Denver")citiesRef.where("country", "==", "USA")         .where("capital", "==", false)         .where("state", "==", "CA")         .where("population", "==", 860000)If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query.
The array-contains index allows you to query the regions array field:
WebcitiesRef.where("regions", "array-contains", "west_coast")// array-contains-any and array-contains use the same indexescitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])Queries supported by composite indexesFirestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "asc")citiesRef.where("country", "==", "USA").where("population", "<", 3800000)citiesRef.where("country", "==", "USA").where("population", ">", 690000)// in and == clauses use the same indexcitiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause.
Collection	Fields indexed	Query scopecities	arrow_upward (or arrow_downward) country, arrow_upward population	CollectionTo run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", "<", 3800000)         .orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", ">", 690000)         .orderBy("population", "desc")
citiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)         .orderBy("population", "desc")Collection	Fields indexed	Query scopecities	arrow_upward country, arrow_upward population	Collectioncities	arrow_upward country, arrow_downward population	CollectionYou also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses.
WebcitiesRef.where("regions", "array-contains", "east_coast")         .where("capital", "==", true)
// array-contains-any and array-contains use the same indexcitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])         .where("capital", "==", true)Collection	Fields indexed	Query scopecities	array-contains tags, arrow_upward (or arrow_downward) capital	CollectionQueries supported by collection group indexesTo demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents:
Webvar citiesRef = db.collection("cities");
citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Bridge",    category : "bridge" });citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Park",    category : "park" });
citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Gallery of Art",    category : "museum" });citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Mall",    category : "park" });Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	CollectionWebcitiesRef.doc("SF").collection("landmarks").where("category", "==", "park")citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"])Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	Collection groupWith this index enabled, you can query the landmarks collection group:
Webvar landmarksGroupRef = db.collectionGroup("landmarks");
landmarksGroupRef.where("category", "==", "park")landmarksGroupRef.where("category", "in", ["park", "museum"])To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions.
For example, you can run the following collection group query without enabling an additional index:
Webdb.collectionGroup("landmarks").get()Index entriesYour project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit.
The following example demonstrates the index entries of a document.
Document/cities/SF
city_name : "San Francisco"temperatures : {summer: 67, winter: 55}neighborhoods : ["Mission", "Downtown", "Marina"]
Single-Field indexescity_name ASCcity_name DESCtemperatures.summer ASCtemperatures.summer DESCtemperatures.winter ASCtemperatures.winter DESCneighborhoods Array Contains (ASC and DESC)Composite indexescity_name ASC, neighborhoods ARRAYcity_name DESC, neighborhoods ARRAYIndex entriesThis indexing configuration results in the following 18 index entries for the document:
Index	Indexed dataSingle-field index entries	city_name ASC	city_name: "San Francisco"city_name DESC	city_name: "San Francisco"temperatures.summer ASC	temperatures.summer: 67temperatures.summer DESC	temperatures.summer: 67temperatures.winter ASC	temperatures.winter: 55temperatures.winter DESC	temperatures.winter: 55neighborhoods Array Contains ASC	neighborhoods: "Mission"neighborhoods Array Contains DESC	neighborhoods: "Mission"neighborhoods Array Contains ASC	neighborhoods: "Downtown"neighborhoods Array Contains DESC	neighborhoods: "Downtown"neighborhoods Array Contains ASC	neighborhoods: "Marina"neighborhoods Array Contains DESC	neighborhoods: "Marina"Composite index entries	city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"Indexes and pricingIndexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size.
Taking advantage of index mergingAlthough Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries.
You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app:
collections_bookmark restaurants
class burgerthyme
name : "Burger Thyme"category : "burgers"city : "San Francisco"editors_pick : truestar_rating : 4
Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating:
Webdb.collection("restaurants").where("category", "==", "burgers")                            .orderBy("star_rating")
db.collection("restaurants").where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==" "San Francisco")                            .where("editors_pick", "==", true )                            .orderBy("star_rating")You could create an index for each query:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating	CollectionAs a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward editors_pick, arrow_upward star_rating	CollectionNot only is this set of indexes smaller, it also supports an additional query:
Webdb.collection("restaurants").where("editors_pick", "==", true)                            .orderBy("star_rating")
Indexing limitsThe following limits apply to indexes. For all quotas and limits, see Quotas and Limits.
This page identifies the request quotas and limits for Firestore.
Limit	DetailsMaximum number of composite indexes for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.
You can contact support to request an increase to this limit.
Maximum number of single-field configurations for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit.
Maximum number of index entries for each document
40,000
The number of index entries is the sum of the following for a document:
The number of single-field index entriesThe number of composite index entriesTo see how Firestore turns a document and a set of indexes into index entries, see this index entry count example.
Maximum number of fields in a composite index	100Maximum size of an index entry	7.5 KiB
To see how Firestore calculates index entry size, see index entry size.
Maximum sum of the sizes of a document's index entries	8 MiB
The total size is the sum of the following for a document:
The sum of the size of a document's single-field index entriesThe sum of the size of a document's composite index entriesMaximum size of an indexed field value	1500 bytes
Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results.
Indexing best practicesFor most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases:
Case	DescriptionLarge string fields	If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing.
High write rates to a collection containing documents with sequential values	If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit.
In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit.
TTL fields	If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields.
Large array or map fields	Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing.
For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page.
Was this helpful?
Send feedbackExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2023-10-26 UTC.
Why GoogleChoosing Google CloudTrust and securityOpen cloudMulticloudGlobal infrastructureCustomers and case studiesAnalyst reportsWhitepapersBlogProducts and pricingGoogle Cloud pricingGoogle Workspace pricingSee all productsSolutionsInfrastructure modernizationDatabasesApplication modernizationSmart analyticsArtificial IntelligenceSecurityProductivity & work transformationIndustry solutionsDevOps solutionsSmall business solutionsSee all solutionsResourcesGoogle Cloud documentationGoogle Cloud quickstartsGoogle Cloud MarketplaceLearn about cloud computingSupportCode samplesCloud Architecture CenterTrainingCertificationsGoogle for DevelopersGoogle Cloud for StartupsSystem statusRelease NotesEngageContact salesFind a PartnerBecome a PartnerEventsPodcastsDeveloper CenterPress CornerGoogle Cloud on YouTubeGoogle Cloud Tech on YouTubeFollow on TwitterJoin User ResearchWe're hiring. Join Google Cloud!Google Cloud CommunityAbout GooglePrivacySite termsGoogle Cloud termsOur third decade of climate action: join usSign up for the Google Cloud newsletterSubscribe
LanguageCopied to clipboardCopied to clipboardvar citiesRef = db.collection("cities");
citiesRef.doc("SF").set({    name: "San Francisco", state: "CA", country: "USA",    capital: false, population: 860000,    regions: ["west_coast", "norcal"] });citiesRef.doc("LA").set({    name: "Los Angeles", state: "CA", country: "USA",    capital: false, population: 3900000,    regions: ["west_coast", "socal"] });citiesRef.doc("DC").set({    name: "Washington, D.C.", state: null, country: "USA",    capital: true, population: 680000,    regions: ["east_coast"] });citiesRef.doc("TOK").set({    name: "Tokyo", state: null, country: "Japan",    capital: true, population: 9000000,    regions: ["kanto", "honshu"] });citiesRef.doc("BJ").set({    name: "Beijing", state: null, country: "China",    capital: true, population: 21500000,    regions: ["jingjinji", "hebei"] });Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index:
Collection	Field indexed	Query scopecities	arrow_upward name	Collectioncities	arrow_upward state	Collectioncities	arrow_upward country	Collectioncities	arrow_upward capital	Collectioncities	arrow_upward population	Collectioncities	arrow_downward name	Collectioncities	arrow_downward state	Collectioncities	arrow_downward country	Collectioncities	arrow_downward capital	Collectioncities	arrow_downward population	Collectioncities	array-contains regions	CollectionQueries supported by single-field indexesUsing these automatically created single-field indexes, you can run simple queries like the following:
Webconst stateQuery = citiesRef.where("state", "==", "CA");const populationQuery = citiesRef.where("population", "<", 100000);const nameQuery = citiesRef.where("name", ">=", "San Francisco");You can also create in and compound equality (==) queries:
WebcitiesRef.where('country', 'in', ["USA", "Japan", "China"])
// Compound equality queriescitiesRef.where("state", "==", "CO").where("name", "==", "Denver")citiesRef.where("country", "==", "USA")         .where("capital", "==", false)         .where("state", "==", "CA")         .where("population", "==", 860000)If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query.
The array-contains index allows you to query the regions array field:
WebcitiesRef.where("regions", "array-contains", "west_coast")// array-contains-any and array-contains use the same indexescitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])Queries supported by composite indexesFirestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "asc")citiesRef.where("country", "==", "USA").where("population", "<", 3800000)citiesRef.where("country", "==", "USA").where("population", ">", 690000)// in and == clauses use the same indexcitiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause.
Collection	Fields indexed	Query scopecities	arrow_upward (or arrow_downward) country, arrow_upward population	CollectionTo run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population:
WebcitiesRef.where("country", "==", "USA").orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", "<", 3800000)         .orderBy("population", "desc")
citiesRef.where("country", "==", "USA")         .where("population", ">", 690000)         .orderBy("population", "desc")
citiesRef.where("country", "in", ["USA", "Japan", "China"])         .where("population", ">", 690000)         .orderBy("population", "desc")Collection	Fields indexed	Query scopecities	arrow_upward country, arrow_upward population	Collectioncities	arrow_upward country, arrow_downward population	CollectionYou also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses.
WebcitiesRef.where("regions", "array-contains", "east_coast")         .where("capital", "==", true)
// array-contains-any and array-contains use the same indexcitiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"])         .where("capital", "==", true)Collection	Fields indexed	Query scopecities	array-contains tags, arrow_upward (or arrow_downward) capital	CollectionQueries supported by collection group indexesTo demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents:
Webvar citiesRef = db.collection("cities");
citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Bridge",    category : "bridge" });citiesRef.doc("SF").collection("landmarks").doc().set({    name: "Golden Gate Park",    category : "park" });
citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Gallery of Art",    category : "museum" });citiesRef.doc("DC").collection("landmarks").doc().set({    name: "National Mall",    category : "park" });Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	CollectionWebcitiesRef.doc("SF").collection("landmarks").where("category", "==", "park")citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"])Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope:
Collection	Fields indexed	Query scopelandmarks	arrow_upward (or arrow_downward) category	Collection groupWith this index enabled, you can query the landmarks collection group:
Webvar landmarksGroupRef = db.collectionGroup("landmarks");
landmarksGroupRef.where("category", "==", "park")landmarksGroupRef.where("category", "in", ["park", "museum"])To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions.
For example, you can run the following collection group query without enabling an additional index:
Webdb.collectionGroup("landmarks").get()Index entriesYour project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit.
The following example demonstrates the index entries of a document.
Document/cities/SF
city_name : "San Francisco"temperatures : {summer: 67, winter: 55}neighborhoods : ["Mission", "Downtown", "Marina"]
Single-Field indexescity_name ASCcity_name DESCtemperatures.summer ASCtemperatures.summer DESCtemperatures.winter ASCtemperatures.winter DESCneighborhoods Array Contains (ASC and DESC)Composite indexescity_name ASC, neighborhoods ARRAYcity_name DESC, neighborhoods ARRAYIndex entriesThis indexing configuration results in the following 18 index entries for the document:
Index	Indexed dataSingle-field index entries	city_name ASC	city_name: "San Francisco"city_name DESC	city_name: "San Francisco"temperatures.summer ASC	temperatures.summer: 67temperatures.summer DESC	temperatures.summer: 67temperatures.winter ASC	temperatures.winter: 55temperatures.winter DESC	temperatures.winter: 55neighborhoods Array Contains ASC	neighborhoods: "Mission"neighborhoods Array Contains DESC	neighborhoods: "Mission"neighborhoods Array Contains ASC	neighborhoods: "Downtown"neighborhoods Array Contains DESC	neighborhoods: "Downtown"neighborhoods Array Contains ASC	neighborhoods: "Marina"neighborhoods Array Contains DESC	neighborhoods: "Marina"Composite index entries	city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name ASC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Mission"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Downtown"city_name DESC, neighborhoods ARRAY	city_name: "San Francisco", neighborhoods: "Marina"Indexes and pricingIndexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size.
Taking advantage of index mergingAlthough Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries.
You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app:
collections_bookmark restaurants
class burgerthyme
name : "Burger Thyme"category : "burgers"city : "San Francisco"editors_pick : truestar_rating : 4
Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating:
Webdb.collection("restaurants").where("category", "==", "burgers")                            .orderBy("star_rating")
db.collection("restaurants").where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==", "San Francisco")                            .orderBy("star_rating")
db.collection("restaurants").where("category", "==", "burgers")                            .where("city", "==" "San Francisco")                            .where("editors_pick", "==", true )                            .orderBy("star_rating")You could create an index for each query:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating	CollectionAs a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses:
Collection	Fields indexed	Query scoperestaurants	arrow_upward category, arrow_upward star_rating	Collectionrestaurants	arrow_upward city, arrow_upward star_rating	Collectionrestaurants	arrow_upward editors_pick, arrow_upward star_rating	CollectionNot only is this set of indexes smaller, it also supports an additional query:
Webdb.collection("restaurants").where("editors_pick", "==", true)                            .orderBy("star_rating")
Indexing limitsThe following limits apply to indexes. For all quotas and limits, see Quotas and Limits.
This page identifies the request quotas and limits for Firestore.
Limit	DetailsMaximum number of composite indexes for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.
You can contact support to request an increase to this limit.
Maximum number of single-field configurations for a database	200 when you have not enabled billing for your Google Cloud project.
If you need more quota, you must enable billing for your Google Cloud project.
500 when you enable billing for your Google Cloud project.One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit.
Maximum number of index entries for each document
40,000
The number of index entries is the sum of the following for a document:
The number of single-field index entriesThe number of composite index entriesTo see how Firestore turns a document and a set of indexes into index entries, see this index entry count example.
Maximum number of fields in a composite index	100Maximum size of an index entry	7.5 KiB
To see how Firestore calculates index entry size, see index entry size.
Maximum sum of the sizes of a document's index entries	8 MiB
The total size is the sum of the following for a document:
The sum of the size of a document's single-field index entriesThe sum of the size of a document's composite index entriesMaximum size of an indexed field value	1500 bytes
Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results.
Indexing best practicesFor most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases:
Case	DescriptionLarge string fields	If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing.
High write rates to a collection containing documents with sequential values	If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit.
In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit.
TTL fields	If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields.
Large array or map fields	Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing.
For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page.
Was this helpful?
Send feedbackExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.
Last updated 2023-10-26 UTC.
Why GoogleChoosing Google CloudTrust and securityOpen cloudMulticloudGlobal infrastructureCustomers and case studiesAnalyst reportsWhitepapersBlogProducts and pricingGoogle Cloud pricingGoogle Workspace pricingSee all productsSolutionsInfrastructure modernizationDatabasesApplication modernizationSmart analyticsArtificial IntelligenceSecurityProductivity & work transformationIndustry solutionsDevOps solutionsSmall business solutionsSee all solutionsResourcesGoogle Cloud documentationGoogle Cloud quickstartsGoogle Cloud MarketplaceLearn about cloud computingSupportCode samplesCloud Architecture CenterTrainingCertificationsGoogle for DevelopersGoogle Cloud for StartupsSystem statusRelease NotesEngageContact salesFind a PartnerBecome a PartnerEventsPodcastsDeveloper CenterPress CornerGoogle Cloud on YouTubeGoogle Cloud Tech on YouTubeFollow on TwitterJoin User ResearchWe're hiring. Join Google Cloud!Google Cloud CommunityAbout GooglePrivacySite termsGoogle Cloud termsOur third decade of climate action: join usSign up for the Google Cloud newsletterSubscribe
LanguageCopied to clipboardCopied to clipboard- [ ] - - [ ] # > > - [ ] - ~~~~~~~~ ~~~~- [ ] - - [ ] # > > - [ ] - ~~~~~~~~ ~~~~https://evt15-6f5b4-default-rtdb.firebaseio.com/121500150081005002004556718temperatures.winter FirestoreDataRulesIndexesUsageExtensionsProtect your Cloud Firestore resources from abuse, such as billing fraud or phishing

array-contains-any and array-contains use the same index citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) .where("capital", "==", true) Collection Fields indexed Query scope cities array-contains tags, arrow_upward (or arrow_downward) capital Collection Queries supported by collection group indexes To demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents: Web var citiesRef = db.collection("cities"); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Bridge", category : "bridge" }); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Park", category : "park" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Gallery of Art", category : "museum" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Mall", category : "park" }); Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection Web citiesRef.doc("SF").collection("landmarks").where("category", "==", "park") citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"]) Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection group With this index enabled, you can query the landmarks collection group: Web var landmarksGroupRef = db.collectionGroup("landmarks"); landmarksGroupRef.where("category", "==", "park") landmarksGroupRef.where("category", "in", ["park", "museum"]) To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions. For example, you can run the following collection group query without enabling an additional index: Web db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. DocumentcitiesSF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle andor its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Google Cloud newsletter Subscribe Language Copied to clipboard Copied to clipboard
(default)
Filevar citiesRef = db.collection("cities"); citiesRef.doc("SF").set({ name: "San Francisco", state: "CA", country: "USA", capital: false, population: 860000, regions: ["west_coast", "norcal"] }); citiesRef.doc("LA").set({ name: "Los Angeles", state: "CA", country: "USA", capital: false, population: 3900000, regions: ["west_coast", "socal"] }); citiesRef.doc("DC").set({ name: "Washington, D.C.", state: null, country: "USA", capital: true, population: 680000, regions: ["east_coast"] }); citiesRef.doc("TOK").set({ name: "Tokyo", state: null, country: "Japan", capital: true, population: 9000000, regions: ["kanto", "honshu"] }); citiesRef.doc("BJ").set({ name: "Beijing", state: null, country: "China", capital: true, population: 21500000, regions: ["jingjinji", "hebei"] }); Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index: Collection Field indexed Query scope cities arrow_upward name Collection cities arrow_upward state Collection cities arrow_upward country Collection cities arrow_upward capital Collection cities arrow_upward population Collection cities arrow_downward name Collection cities arrow_downward state Collection cities arrow_downward country Collection cities arrow_downward capital Collection cities arrow_downward population Collection cities array-contains regions Collection Queries supported by single-field indexes Using these automatically created single-field indexes, you can run simple queries like the following: Web const stateQuery = citiesRef.where("state", "==", "CA"); const populationQuery = citiesRef.where("population", "<", 100000); const nameQuery = citiesRef.where("name", ">=", "San Francisco"); You can also create in and compound equality (==) queries: Web citiesRef.where('country', 'in', ["USA", "Japan", "China"])Error loading documentsCompound equality queries citiesRef.where("state", "==", "CO").where("name", "==", "Denver") citiesRef.where("country", "==", "USA") .where("capital", "==", false) .where("state", "==", "CA") .where("population", "==", 860000) If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query. The array-contains index allows you to query the regions array field: Web citiesRef.where("regions", "array-contains", "west_coast")Error loading documentarray-contains-any and array-contains use the same indexes citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) Queries supported by composite indexes Firestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries: Web citiesRef.where("country", "==", "USA").orderBy("population", "asc") citiesRef.where("country", "==", "USA").where("population", "<", 3800000) citiesRef.where("country", "==", "USA").where("population", ">", 690000)Error loading documentsin and == clauses use the same index citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause. Collection Fields indexed Query scope cities arrow_upward (or arrow_downward) country, arrow_upward population Collection To run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population: Web citiesRef.where("country", "==", "USA").orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", "<", 3800000) .orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", ">", 690000) .orderBy("population", "desc") citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) .orderBy("population", "desc") Collection Fields indexed Query scope cities arrow_upward country, arrow_upward population Collection cities arrow_upward country, arrow_downward population Collection You also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses. Web citiesRef.where("regions", "array-contains", "east_coast") .where("capital", "==", true)Error loading documentarray-contains-any and array-contains use the same index citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) .where("capital", "==", true) Collection Fields indexed Query scope cities array-contains tags, arrow_upward (or arrow_downward) capital Collection Queries supported by collection group indexes To demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents: Web var citiesRef = db.collection("cities"); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Bridge", category : "bridge" }); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Park", category : "park" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Gallery of Art", category : "museum" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Mall", category : "park" }); Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection Web citiesRef.doc("SF").collection("landmarks").where("category", "==", "park") citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"]) Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection group With this index enabled, you can query the landmarks collection group: Web var landmarksGroupRef = db.collectionGroup("landmarks"); landmarksGroupRef.where("category", "==", "park") landmarksGroupRef.where("category", "in", ["park", "museum"]) To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions. For example, you can run the following collection group query without enabling an additional index: Web db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. DocumentError loading documentscitiesError loading documentSF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle andError loading documentsor its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Google Cloud newsletter Subscribe Language Copied to clipboard Copied to clipboardError loading documentDatabase location: nam5Start a collection1 Give the collection an ID2 Parent path/var citiesRef = db.collection("cities"); citiesRef.doc("SF").set({ name: "San Francisco", state: "CA", country: "USA", capital: false, population: 860000, regions: ["west_coast", "norcal"] }); citiesRef.doc("LA").set({ name: "Los Angeles", state: "CA", country: "USA", capital: false, population: 3900000, regions: ["west_coast", "socal"] }); citiesRef.doc("DC").set({ name: "Washington, D.C.", state: null, country: "USA", capital: true, population: 680000, regions: ["east_coast"] }); citiesRef.doc("TOK").set({ name: "Tokyo", state: null, country: "Japan", capital: true, population: 9000000, regions: ["kanto", "honshu"] }); citiesRef.doc("BJ").set({ name: "Beijing", state: null, country: "China", capital: true, population: 21500000, regions: ["jingjinji", "hebei"] }); Assuming the default automatic indexing settings, Firestore updates one ascending single-field index per non-array field, one descending single- field index per non-array field, and one array-contains single-field index for the array field. Each row in the following table represents an entry in a single-field index: Collection Field indexed Query scope cities arrow_upward name Collection cities arrow_upward state Collection cities arrow_upward country Collection cities arrow_upward capital Collection cities arrow_upward population Collection cities arrow_downward name Collection cities arrow_downward state Collection cities arrow_downward country Collection cities arrow_downward capital Collection cities arrow_downward population Collection cities array-contains regions Collection Queries supported by single-field indexes Using these automatically created single-field indexes, you can run simple queries like the following: Web const stateQuery = citiesRef.where("state", "==", "CA"); const populationQuery = citiesRef.where("population", "<", 100000); const nameQuery = citiesRef.where("name", ">=", "San Francisco"); You can also create in and compound equality (==) queries: Web citiesRef.where('country', 'in', ["USA", "Japan", "China"]) / Compound equality queries citiesRef.where("state", "==", "CO").where("name", "==", "Denver") citiesRef.where("country", "==", "USA") .where("capital", "==", false) .where("state", "==", "CA") .where("population", "==", 860000) If you need to run a compound query that uses a range comparison (<, <=, >, or >=) or if you need to sort by a different field, you must create a composite index for that query. The array-contains index allows you to query the regions array field: Web citiesRef.where("regions", "array-contains", "west_coast") / array-contains-any and array-contains use the same indexes citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) Queries supported by composite indexes Firestore uses composite indexes to support compound queries not already supported by single-field indexes. For example, you would need a composite index for the following queries: Web citiesRef.where("country", "==", "USA").orderBy("population", "asc") citiesRef.where("country", "==", "USA").where("population", "<", 3800000) citiesRef.where("country", "==", "USA").where("population", ">", 690000) / in and == clauses use the same index citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) These queries require the composite index below. Since the query uses an equality (== or in) for the country field, you can use an ascending or descending index mode for this field. By default, inequality clauses apply an ascending sort order based on the field in the inequality clause. Collection Fields indexed Query scope cities arrow_upward (or arrow_downward) country, arrow_upward population Collection To run the same queries but with a descending sort order, you need an additional composite index in the descending direction for population: Web citiesRef.where("country", "==", "USA").orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", "<", 3800000) .orderBy("population", "desc") citiesRef.where("country", "==", "USA") .where("population", ">", 690000) .orderBy("population", "desc") citiesRef.where("country", "in", ["USA", "Japan", "China"]) .where("population", ">", 690000) .orderBy("population", "desc") Collection Fields indexed Query scope cities arrow_upward country, arrow_upward population Collection cities arrow_upward country, arrow_downward population Collection You also need to create a composite index to combine an array-contains or array-contains-any query with additional clauses. Web citiesRef.where("regions", "array-contains", "east_coast") .where("capital", "==", true) / array-contains-any and array-contains use the same index citiesRef.where("regions", "array-contains-any", ["west_coast", "east_coast"]) .where("capital", "==", true) Collection Fields indexed Query scope cities array-contains tags, arrow_upward (or arrow_downward) capital Collection Queries supported by collection group indexes To demonstrate an index with collection group scope, imagine you add a landmarks sub-collection to some of the city documents: Web var citiesRef = db.collection("cities"); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Bridge", category : "bridge" }); citiesRef.doc("SF").collection("landmarks").doc().set({ name: "Golden Gate Park", category : "park" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Gallery of Art", category : "museum" }); citiesRef.doc("DC").collection("landmarks").doc().set({ name: "National Mall", category : "park" }); Using the following single-field index with collection scope, you can query a single city's landmarks collection based on the category field: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection Web citiesRef.doc("SF").collection("landmarks").where("category", "==", "park") citiesRef.doc("SF").collection("landmarks").where("category", "in", ["park", "museum"]) Now, imagine that you're interested in querying the landmarks across all cities. To run this query on the collection group consisting of all landmarks collections, you must enable a landmarks single-field index with collection group scope: Collection Fields indexed Query scope landmarks arrow_upward (or arrow_downward) category Collection group With this index enabled, you can query the landmarks collection group: Web var landmarksGroupRef = db.collectionGroup("landmarks"); landmarksGroupRef.where("category", "==", "park") landmarksGroupRef.where("category", "in", ["park", "museum"]) To run a collection group query that returns filtered or ordered results, you must enable a corresponding single-field or composite index with collection group scope. Collection group queries that don't filter or order results, however, do not require any additional index definitions. For example, you can run the following collection group query without enabling an additional index: Web db.collectionGroup("landmarks").get() Index entries Your project's configured indexes and the structure of a document determine the number of index entries for a document. Index entries count towards the index entry count limit. The following example demonstrates the index entries of a document. Document /cities/SF city_name : "San Francisco" temperatures : {summer: 67, winter: 55} neighborhoods : ["Mission", "Downtown", "Marina"] Single-Field indexes city_name ASC city_name DESC temperatures.summer ASC temperatures.summer DESC temperatures.winter ASC temperatures.winter DESC neighborhoods Array Contains (ASC and DESC) Composite indexes city_name ASC, neighborhoods ARRAY city_name DESC, neighborhoods ARRAY Index entries This indexing configuration results in the following 18 index entries for the document: Index Indexed data Single-field index entries city_name ASC city_name: "San Francisco" city_name DESC city_name: "San Francisco" temperatures.summer ASC temperatures.summer: 67 temperatures.summer DESC temperatures.summer: 67 temperatures.winter ASC temperatures.winter: 55 temperatures.winter DESC temperatures.winter: 55 neighborhoods Array Contains ASC neighborhoods: "Mission" neighborhoods Array Contains DESC neighborhoods: "Mission" neighborhoods Array Contains ASC neighborhoods: "Downtown" neighborhoods Array Contains DESC neighborhoods: "Downtown" neighborhoods Array Contains ASC neighborhoods: "Marina" neighborhoods Array Contains DESC neighborhoods: "Marina" Composite index entries city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name ASC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Mission" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Downtown" city_name DESC, neighborhoods ARRAY city_name: "San Francisco", neighborhoods: "Marina" Indexes and pricing Indexes contribute to the storage costs of your application. For more on how storage size for indexes is calculated, see Index entry size. Taking advantage of index merging Although Firestore uses an index for every query, it does not necessarily require one index per query. For queries with multiple equality (==) clauses and, optionally, an orderBy clause, Firestore can re-use existing indexes. Firestore can merge the indexes for simple equality filters to build the composite indexes needed for larger equality queries. You can reduce indexing costs by identifying situations where you can take advantage of index merging. For example, imagine a restaurants collection for a restaurant rating app: collections_bookmark restaurants class burgerthyme name : "Burger Thyme" category : "burgers" city : "San Francisco" editors_pick : true star_rating : 4 Now, imagine this app uses queries like the ones below. Notice that the app uses combinations of equality clauses for category, city, and editors_pick while always sorting by ascending star_rating: Web db.collection("restaurants").where("category", "==", "burgers") .orderBy("star_rating") db.collection("restaurants").where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==", "San Francisco") .orderBy("star_rating") db.collection("restaurants").where("category", "==", "burgers") .where("city", "==" "San Francisco") .where("editors_pick", "==", true ) .orderBy("star_rating") You could create an index for each query: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward category, arrow_upward city, arrow_upward editors_pick, arrow_upward star_rating Collection As a better solution, you can reduce the number of indexes by taking advantage of Firestore's ability to merge indexes for equality clauses: Collection Fields indexed Query scope restaurants arrow_upward category, arrow_upward star_rating Collection restaurants arrow_upward city, arrow_upward star_rating Collection restaurants arrow_upward editors_pick, arrow_upward star_rating Collection Not only is this set of indexes smaller, it also supports an additional query: Web db.collection("restaurants").where("editors_pick", "==", true) .orderBy("star_rating") Indexing limits The following limits apply to indexes. For all quotas and limits, see Quotas and Limits. This page identifies the request quotas and limits for Firestore. Limit Details Maximum number of composite indexes for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. You can contact support to request an increase to this limit. Maximum number of single-field configurations for a database 200 when you have not enabled billing for your Google Cloud project. If you need more quota, you must enable billing for your Google Cloud project. 500 when you enable billing for your Google Cloud project. One field level configuration can contain multiple configurations for the same field. For example, a single-field indexing exemption and a TTL policy on the same field count as one field configuration towards the limit. Maximum number of index entries for each document 40,000 The number of index entries is the sum of the following for a document: The number of single-field index entries The number of composite index entries To see how Firestore turns a document and a set of indexes into index entries, see this index entry count example. Maximum number of fields in a composite index 100 Maximum size of an index entry 7.5 KiB To see how Firestore calculates index entry size, see index entry size. Maximum sum of the sizes of a document's index entries 8 MiB The total size is the sum of the following for a document: The sum of the size of a document's single-field index entries The sum of the size of a document's composite index entries Maximum size of an indexed field value 1500 bytes Field values over 1500 bytes are truncated. Queries involving truncated field values may return inconsistent results. Indexing best practices For most apps, you can rely on automatic indexing and the error message links to manage your indexes. However, you may want to add single-field exemptions in the following cases: Case Description Large string fields If you have a string field that often holds long string values that you don't use for querying, you can cut storage costs by exempting the field from indexing. High write rates to a collection containing documents with sequential values If you index a field that increases or decreases sequentially between documents in a collection, like a timestamp, then the maximum write rate to the collection is 500 writes per second. If you don't query based on the field with sequential values, you can exempt the field from indexing to bypass this limit. In an IoT use case with a high write rate, for example, a collection containing documents with a timestamp field might approach the 500 writes per second limit. TTL fields If you use TTL (time-to-live) policies, note that the TTL field must be a timestamp. Indexing on TTL fields is enabled by default and can affect performance at higher traffic rates. As a best practice, add single-field exemptions for your TTL fields. Large array or map fields Large array or map fields can approach the limit of 40,000 index entries per document. If you are not querying based on a large array or map field, you should exempt it from indexing. For more information on how to resolve indexing issues (index fanout, INVALID_ARGUMENT errors) check out the troubleshooting page. Was this helpful? Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates. Last updated 2023-10-26 UTC. Why Google Choosing Google Cloud Trust and security Open cloud Multicloud Global infrastructure Customers and case studies Analyst reports Whitepapers Blog Products and pricing Google Cloud pricing Google Workspace pricing See all products Solutions Infrastructure modernization Databases Application modernization Smart analytics Artificial Intelligence Security Productivity & work transformation Industry solutions DevOps solutions Small business solutions See all solutions Resources Google Cloud documentation Google Cloud quickstarts Google Cloud Marketplace Learn about cloud computing Support Code samples Cloud Architecture Center Training Certifications Google for Developers Google Cloud for Startups System status Release Notes Engage Contact sales Find a Partner Become a Partner Events Podcasts Developer Center Press Corner Google Cloud on YouTube Google Cloud Tech on YouTube Follow on Twitter Join User Research We're hiring. Join Google Cloud! Google Cloud Community About Google Privacy Site terms Google Cloud terms Our third decade of climate action: join us Sign up for the Googletemperatures.summertemperatures.winter186755420050010081500Googletemperatures.wintertemperatures.summervarDESCtemperatures.summerASCtemperatures.summerDESCtemperatures.winterASCtemperatures.winter67temperatures.summer67temperatures.winter55temperatures.winterproject.One121500150081005002004556
